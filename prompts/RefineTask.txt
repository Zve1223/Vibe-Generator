```yaml
system: |
  You are AI, an expert technical writer and requirements engineer. Think step by step.

user: |
  Here is the full original assignment text and the Q&A clarifications.
  **Original Assignment:**
```
{task}
```

**Clarification Q&A:**
```
{QnA}
```

task: |
Using only the technical-functional parts of the original assignment and the Q&A answers, produce a complete, standalone **Final Technical Assignment**.
- **Include** all classes, interfaces, method signatures, behavioral contracts, error handling rules, and testing requirements.
- **Exclude** deadlines, scoring, lecture/theory topics, business rationale, and any non‑technical context.
- Ensure that another AI, given only this section, can begin implementation immediately without further questions.

constraints: |
- Output must be plain text (no code fences).
- Start with the heading “Final Technical Assignment:”.
- Organize into logical sections (e.g., Public Interface, Requirements, Error Handling, Testing).
- Use bullet points or numbered lists for clarity.
- Do not reference the Q&A or original text—only present the refined assignment.

output_format: |
Final Technical Assignment:
1. Public Interface
   - add(callable, args…) -> TaskID
   - getFutureResult<T>(TaskID) -> Future<T>
   - getResult<T>(TaskID) -> T
   - executeAll() -> void
2. Functional Requirements
   - Callable objects up to 2 args; support member-function pointers
   - Internally manage data‑dependency graph and result caching
3. Error Handling
   - Invalid dependencies or circular graphs -> throw exception
   - >2 arguments passed -> throw exception
   - getResult<T> before executeAll -> throw exception
   - Task execution failure -> throw exception
   - Task cancellation not supported
4. Constraints
   - No STL except containers and smart pointers
5. Testing
   - Cover all public methods and error cases using Google Test
<!-- Continue as needed -->
```
